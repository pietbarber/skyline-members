#!/usr/bin/perl

	# Little program to display test questions, as appropriate


	# Todo: 
	
    	# Immediate To-do list: 
    	# [X] Start.	
	# [X] If the list of questions doesn't pan out, complain n stuff. 
	# [X] Display test questions in a print-outable format for the instructor. 
	# [X] Make the PDF page line break in the right places, and not line-break in the 
	#     middle of a test question table cell. 
	# [X] QR Codes to tests (so we don't have to print the answer sheet
	# [X] New directory for each test made - cuts down on the ARCHIVES directory clutter
	# [X] Describes the subjects included for this test at the top of the question sheet
	# [X] Bob Sallada wants to have the freedom to mark specific questions that MUST be included
	#     in the test.  not so hard. 
	# [ ] Remove &ensp; &thinsp; &emsp; tags from the HTML because wkhtmltopdf blows up. 
	#
    	# Later to-do list:  This can be done later, so long as I don't get distracted by video games.  
	# 
    	# Student Test Experience (I mean the online test-taking experience):
    	# [ ] Start.
	# [ ] Display test questions in a print-outable format for the instructor. 
    	# [ ] Have the student pick up a test generated by the instructor
    	# [ ] One big page that doesn't let the student use the back button to fix the test problems
    	# [ ] Include time limit javascript to pressure the student into making stupid decisions based on a time limit
    	# [ ] Enter results of written tests into their flight training record, including and especially including 
	# [ ] Send the email inviting the student to take the test. 
	#     links to the incorrect answers.
    	# [ ] Come up with a 1WH to keep the student from figuring out how to snoop the whole test bank by clever 
	#     use of URLs and hackery. 
	# 

$|++;
use strict;
my ($DEBUG) = 0; 
#my ($DEBUG) = 1; 
#my ($the_instructor) = 'pbarber'; 
my ($the_instructor) = $ENV{'REMOTE_USER'}; 
my ($min_questions) = 1;

use CGI qw(:standard);
use DBI;
my ($dbh);
connectify();

if (param ('action') eq 'Create Test') {
  create_test_matter();
  }

elsif (param('usetest') eq 'Print This Test') {
	# User elected to use the test we generated.
	# so give the instructor PDFs to print out. 
  print join ("\n",
    header(),
    start_html(-title => "PDF Test Documents"),
    include('left-menu.scrap'),
    start_form(), 
    h1("PDF Test Documents"), 
    qq(<a href="?">Return to Main</a><br>), 
    p(qq(Download each PDF here,))
    );

  my (@questions);
  for my $question (param()) {
    if ($question =~ /^q-(\d+)$/ ){
      push (@questions, param($question)); 
      }
    }

  print qq(<table border="0"><tr><td>);
  my ($dirname) = make_archive_directory();
  generate_pdf_questions($dirname, @questions);
  generate_pdf_answers($dirname, @questions);
  print qq(</td></tr><tr><td>);
  generate_pdf_testsheet($dirname, @questions);
  generate_pdf_answersheet($dirname, @questions);
  print qq(</td></tr></table>);
  print qq(<p>To save paper, you need not print the Answers and Explanations page.  If you have a smartphone, you can follow the QR Code at the top of the test document, that takes your smartphone to tests, answers, crib sheets that you just generated. You can also follow and bookmark this URL: <a href="$dirname">http://members.skylinesoaring.org/INSTRUCTORS/TEST/$dirname</a></p>);
  footer();
  }

else { 

  print join ("\n",
    header(),
    start_html(-title => "Create a Written Test"),
    include('left-menu.scrap'),
    start_form(), 
    h1("Create a Written Test"), 
    qq(<a href="/INSTRUCTORS/TEST/">Return to Main</a><br>), 
    );
  show_question_selection(); 
  } 

footer(); 

	# Subroutines lie here and yonder!

sub make_archive_directory {
	# Create the directory where the test pages will be dropped. 
	# We should properly drop in a README.shtml 
	# and a HEADER.shtml. 
	# the output of this subroutine is the name of the directory
	# relative to /INSTRUCTORS/TEST/" 
	# Make sure the directory is group-apache writable.  (umask)

  abort("Illegal User Name (" . $ENV{'REMOTE_USER'}. ")") if ($ENV{'REMOTE_USER'} =~ /[^A-Za-z0-9]/);
  my ($datename) = `date +%Y%m%d%H%M%S`; 
  chomp ($datename); 
  umask ('0003');
  my ($dirname);
  $dirname = 'ARCHIVES/' . $datename . '-' . $ENV{'REMOTE_USER'}; 
  $dirname = 'ARCHIVES/test' if ($DEBUG > 1); 
  mkdir "$dirname";
  open (README, ">$dirname/README.shtml") || abort ("unable to write to $dirname/README.shtml");
  print README qq(<!--#Include Virtual="/INCLUDES/footer.scrap"-->\n);
  close (README);

  open (HEADER, ">$dirname/HEADER.shtml") || abort ("unable to write to $dirname/README.shtml");
  my ($date) = scalar(localtime(time));
  my (%handle) = fetch_members (); 
  my ($dude) = $handle{$ENV{'REMOTE_USER'}};
  print HEADER <<EOM;
<!DOCTYPE HTML>

<html>
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<LINK REL="SHORTCUT ICON" href="/favicon.ico">
    <title>Instructors' Written Tests</title>
<!--#INCLUDE virtual="/INCLUDES/left-menu.scrap"-->

<h1>Written Tests</h1>

<p>This was generated on $date by $dude.</p>

<p>Access to this page is permitted only to current club Instructors</p>

<p>File naming convention is as follows:
<ul>
<li>testsheet -- The page where the student marks his answers
<li>questions -- The actual test
<li>cribsheet -- easy page to help the instructor grade the test.
<li>answers -- explanations for all of the answers we chose
</ul>
EOM
  close (HEADER);

  $dirname;
  }

sub generate_pdf_questions {

	# So we'll go through the questions array
	# and print the questions to a file. 
  my ($dirname) = shift; 
  my (@questions) = @_; 
  my ($question_count);
  my ($qfilename) = "$dirname/questions.html";
  my ($pfilename) = "$dirname/questions.pdf";
  open (QFILE, ">$qfilename")
	|| abort ("Can't write to the filename $qfilename $!\n");
  select (QFILE);
  print start_html (-title=>"SSC Written Test");
	# Here's the QR Code we get from Google.  This may stop working after April 2015. :(
	# At that point, we'll have to get a new method to generate QR Codes. :( :( 
  print qq(<img align="right" src="http://chart.apis.google.com/chart?cht=qr&chs=100x100&chl=http%3A//members.skylinesoaring.org/INSTRUCTORS/TEST/$dirname&chld=H|0">);
  print h1(qq(Skyline Soaring Club Written Test));
  print p(qq(Please do not write on this question sheet. Use the separate answer sheet that has been supplied by
	your instructor. <p><font size="-1"><u>Subjects covered on this test:</u> ) . param('subjects') . "</font></p>"); 

  for my $question (@questions) { 
    print print_question($question,++$question_count); 
    }
  select (STDOUT);
  #open (EXEC, "-|") || exec ("/home/httpd/bin/wkhtmltopdf-i386", '--enable-smart-shrinking', '-q', '-s', 'letter', $qfilename, $pfilename); 
  open (EXEC, "-|") || exec ("/home/httpd/bin/wkhtmltopdf-amd64", '--enable-smart-shrinking', '-q', '-s', 'letter', $qfilename, $pfilename); 
  close (EXEC); 
  print qq(<td align="center"> <a href="$pfilename"><img src="/IMAGES/PDF-icon.jpeg" border="0"><br>Download Written Test</td>);
  }

sub generate_pdf_answers {
	# So we'll go through the questions array
	# and print the appropriate answers to a different file. 
  my ($dirname) = shift; 
  my (@questions) = @_; 
  my ($question_count);
  my ($filename) = time; 
  my ($qfilename) = "$dirname/answers.html";
  my ($pfilename) = "$dirname/answers.pdf";
  open (QFILE, ">$qfilename")
	|| abort ("Can't write to the filename $qfilename $!\n");
  select (QFILE);
  print start_html (-title=>"SSC Answers and Explanations ");
  print h1(qq(SSC Answers and Explanations));
  print p(qq(Instructors: The answers and explanations for the questions are as follows: )); 
  print qq(<font size="-2"><table border="1">\n);
  for my $question (@questions) { 
    print "\n<!-- " . ($question_count+1) . " -->\n";
    print print_answer($question,++$question_count); 
    }
  print qq(\t</table>\n</font>);
  select (STDOUT);
  open (EXEC, "-|") || exec ("/home/httpd/bin/wkhtmltopdf-amd64", '--enable-smart-shrinking', '-q', '-s', 'letter', $qfilename, $pfilename); 
  close (EXEC); 
  print qq(<td align="center"> <a href="$pfilename"><img src="/IMAGES/PDF-icon.jpeg" border="0"><br>Answers and Explanations</td>);
  }

sub generate_pdf_testsheet {
	# This is the test sheet where the student will fill in his answers. 
  my ($dirname) = shift; 
  my (@questions) = @_; 
  my ($question_count);
  my ($filename) = time; 
  my ($qfilename) = "$dirname/testsheet.html";
  my ($pfilename) = "$dirname/testsheet.pdf";
  open (QFILE, ">$qfilename")
	|| abort ("Can't write to the filename $qfilename $!\n");
  select (QFILE);
  print start_html (-title=>"SSC Test Sheet");
  print h1(qq(SSC Test Sheet));
  print p(qq(Student: Mark your answers in the boxes below. )); 
  print qq(<table border="0"><tr><td>);
  my ($count);
  print "<pre>\n";
  while (my $question= shift @questions) {
    printf qq(%2.2d  [ A ]  [ B ]  [ C ]  [ D ]\n\n), ++$count;
    last if $count == 25; 
    }
  print "</pre>";
  print "</td>";
  print "<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>";
  print qq(<td valign="top">);
  print "<pre>\n";
  while (my $question=shift @questions) {
    printf qq(%2.2d  [ A ]  [ B ]  [ C ]  [ D ]\n\n), ++$count;
    }
  print "</pre>";
  print "</td>";
  print "</table>"; 

  print qq(</table></font>);
  select (STDOUT);
  open (EXEC, "-|") || exec ("/home/httpd/bin/wkhtmltopdf-amd64", '--enable-smart-shrinking', '-q', '-s', 'letter', $qfilename, $pfilename); 
  close (EXEC); 
  print qq(<td align="center"><a href="$pfilename"><img src="/IMAGES/PDF-icon.jpeg" border="0"><br>Test Sheet</td>);
  }

sub generate_pdf_answersheet {
	# This is the crib sheet that shows the answers
	# so the instructor can quickly grade the test. 
  my ($dirname) = shift; 
  my (@questions) = @_; 
  my ($question_count);
  my ($filename) = time; 
  my ($qfilename) = "$dirname/cribsheet.html";
  my ($pfilename) = "$dirname/cribsheet.pdf";
  open (QFILE, ">$qfilename")
	|| abort ("Can't write to the filename $qfilename $!\n");
  select (QFILE);
  print start_html (-title=>"SSC Answer Sheet");
  print h1(qq(SSC Answer Sheet));
  print p(qq(Instructors: Use this sheet to quickly correct the student's test. )); 
  print qq(<table border="0"><tr><td>);
  my ($count);
  print "<pre>\n";
  while (my $question=shift @questions) {
    printf qq(%2.2d  [ %s ]  [ %s ]  [ %s ]  [ %s ]\n\n), 
	++$count,
        answers_for($question);
	;
    last if $count == 25; 
    }
  print "</pre>";
  print "</td>";
  print "<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>";
  print qq(<td valign="top">);
  print "<pre>";
  while (my $question= shift @questions) {
    printf qq(%2.2d  [ %s ]  [ %s ]  [ %s ]  [ %s ]\n\n), 
	++$count,
        answers_for($question);
	;
    }
  print "</pre>";
  print "</td>";
  print "</tr>";
  print "</table>"; 

  print qq(</table></font>);
  select (STDOUT);
  open (EXEC, "-|") || exec ("/home/httpd/bin/wkhtmltopdf-amd64", '--enable-smart-shrinking', '-q', '-s', 'letter', $qfilename, $pfilename); 
  close (EXEC); 
  print qq(<td align="center"> <a href="$pfilename"><img src="/IMAGES/PDF-icon.jpeg" border="0"><br>Test Sheet Answers</td>);
  }

sub answers_for {
	# Input: a question number
	# Output: an aray with spaces where it's not the right answer, "X" where it's the right answer. 
  my ($input) = shift; 
  my (@output); 
  my ($sql) = qq(select answer from test_contents where qnum=$input);
  my $get_info = $dbh->prepare($sql); 
  $get_info->execute();
  my (@fields) = qw(answer); 
  my (%questions);
  while ( my $row = $get_info->fetchrow_hashref ) {
    for my $field (@fields) { 
      $questions{$field}=$row->{'answer'}; 
      } 
    }
  for my $field (qw(A B C D)) {
    if ($field eq $questions{'answer'}) {
      push (@output, "X");
      }
    else {
      push (@output, " ");
      }
    }
  @output;
  }

sub create_test_matter {
	# In a previous run, the instructor selected 
	# the various test question subject matters that 
	# he was going to give the student. 
	# Here we collect up all the things like how many
	# questions, and of which subject shall we collect 
	# the questions, then we'll print them all out. 

	# But first!  We have to verify that the last form
	# was filled out correctly. 

	# More than 10 questions for the test?
  my (%code_names) = code_names();
  my ($count); 
  my (@he_wants, @must_included);
  my $total_possible = 0; 
	# If the instructor forced some question numbers to be included in the test... 
  if (param('must_include') =~ /\d/) {
    @he_wants = split (/\s+|,/, param('must_include')); 
    warn ("It looks like duder wants extra questions, numbers " . join (", ", @he_wants) . "\n"); 
	# Now we'll add it to the list of questions couted up. 
    for my $line (@he_wants) {
      if (is_question_legit($line)) { 
        push (@must_included, $line);
        }
      else {
        warn "Duder put in a question that doesn't exist in the db. '$line'\n"; 
        }
      }
    
    $total_possible = scalar (@must_included); 
    }
  $count += $total_possible;
  for my $code (keys %code_names) {
    $count += param($code);
    }
  if ($count < $min_questions) {
    print join ("\n",
      header(),
      start_html(-title => "Inadequate Questions"),
      include('left-menu.scrap'),
      h1('Inadequate Number of Questions')
      );

    print "You need to have at least $min_questions questions for the test. I counted only $count. Choose more subjects, or choose a higher number from the subject that you already chose."; 
    print h1("Create Test"). 
	  qq(<a href="?">Return to Main</a><br>);
    show_question_selection();
    footer(); 
    }


	# At least one question field had something other than 'none'?
  my %code_name = code_names(); 
  my %code_count = show_code_counts(); 
  my (@codes_used);
  for my $code (keys %code_name) {
    if (param ($code) > 0 && param($code) ne '') { 
      print "Adding $code with a requested quantity of " . param($code) . " Adding " . $code_count{$code} . " questions...<br>\n" if ($DEBUG > 2);
      $total_possible += param($code);
      push (@codes_used, $code_name{$code}) unless $code_count{$code} < 1;
      }
    }

  if ($total_possible < 10) {
    print join ("\n",
      header(),
      start_html(-title => "Question Overdraft"),
      include('left-menu.scrap'),
      h1('Question Overdraft'),
      qq(There aren't enough questions in the test bank to generate a test of the minimum number of questions (10). Given the subjects selected, we could only come up with $total_possible different questions to use.   Could you select a few more test content question areas?)
      );
    show_question_selection();
    footer();
    }

	# Was the sum of all questions collected was at least 
	# the size that the instructor chose? 

  if ($total_possible < param('number_of_questions')) {
    print join ("\n",
      header(),
      start_html(-title => "Question Overdraft"),
      include('left-menu.scrap'),
      h1('Question Overdraft'),
      qq"There aren't enough questions in the test bank to generate a test of the minimum number of questions you required (" , 
      param('number_of_questions') , 
      "). Given the subjects selected, we could only come up with $total_possible different questions to use.   Please select a few more test content question areas, or reduce the required size of the test",
      );
    show_question_selection();
    footer();
    }

	# OK, your selections for a test type seem to be OK. 
	# Let's generate a list of questions and mix em up... 


	# Then we'll print out the projected test... 

  print join ("\n",
    header(),
    start_html(-title => "Review SSC Written Test"),
    include('left-menu.scrap'),
    h1(qq(Review SSC Written Test))
    );
  print qq(<table border="0"><tr><td>);
  my @questions = generate_test_content(@must_included);
  my %questions;
	# First button -- Scramble Questions

  print start_form();
  for my $key (param()) {
    print hidden (
	-name => $key,
	-value => param($key)
	);
    print "\n"; 
    }
  print submit (
		-name => 'usetest', 
		-value => 'Scramble Questions'
		); 
  print end_form();
  print "<td>";	
	# Second button -- Generate New Test

  print start_form();
  for my $key (param()) {
    next if $key eq 'action';
    print hidden (
	-name => $key,
	-value => param($key)
	);
    print "\n"; 
    }
  print submit (
		-name => 'usetest', 
		-value => 'Generate New Test'
		); 
  print end_form();
	# Third button. Print this test. 
  print "<td>";
  print start_form();
  print hidden (-name => 'subjects', -value => join (', ', @codes_used));
  my $count;
  for my $question (@questions) {
    print hidden (
	-name => 'q-' . ++$count, 
	-value => $question
	);
    $questions{$question}=$count;
    print "\n"; 
    }
  print submit (
		-name => 'usetest', 
		-value => 'Print This Test',
		); 
  print end_form();
	# Last button, for the scenario of: "I hate question #2, I want to edit it."
  print "<td>";
  print start_form(
		-action => '/INSTRUCTORS/TEST/edittest.cgi'
		); 
  print "<nobr>"; 
  print popup_menu (
	-name => 'qnum',
	-values => [@questions],
	-labels => \%questions
	) .
	submit (
	-name => 'action',
	-value => 'Edit Test Questions',
	-target => 'Edit_test'
	); 
  print "</nobr>"; 
  print end_form();
  print qq(</table>);
  #print qq(<table border="1">);
  my ($question_count);
  for my $question (@questions) { 
    print print_question($question,++$question_count); 
    }
  #print qq(</table>);
  footer();
  }
  
sub generate_test_content {
  my (@must_included) = @_; 
  my @answer; 
	# OK, so we have to figure out which questions to make. 
	# but first, we have some questions which have to be included, 
	# not negotiable.  Those are in the @must_included array. 
	# After we have that established, go through all of the 
	# parameters that are in %code_name... 
	# Then put them all into an array and chomp out any excesses 
	# over the number_of_questions parameter. 
	# then slap all the question numbers into an array 
	# and return it. 
	# 
  my @rander; 
  my @rand;
  my %code_names = code_names();
  for my $code (keys %code_names) {
    next if (param($code) == 0 || param($code) eq ''); 
    @rander = randomize(questions_per_section($code));
    for (0..(param($code)-1)) { 
      my $ans = shift(@rander); 
      push (@rand, $ans) unless $ans !~ /^\d+$/;
      }
    }
  @answer=(@must_included, @rand);
  while (scalar(@answer) > 50) {
    shift @answer; 
    }
	# Then we'll scramble it on return...
  randomize(@answer);
  }

sub randomize {
	# unsorter routine that takes an array inbound
	# jumbles it up
	# returns the jumbled array. 
	# contents remain the same, just in different order. 
  my @input  = @_; 
  my %temper; 
  my @output; 
  for my $line (@input) {
    $temper{rand($#input)}=$line; 
    }
  for my $line (keys(%temper)) {
    push (@output, $temper{$line}); 
    }
  @output;
  } 

sub is_user_instructor {
        # Get information about this user who is logged in
        # see what kind of reports he/she can view.
        # Are you an instructor? If so you can see anything
        # Are you a student? Then you can only see reports about you...
        # ...You can also only see reports that are safe for your virgin
        # eyes to view. (which the instructor determined).

  my $user = shift;
  my $answer;
  my $get_info = $dbh->prepare(qq(select handle from members where handle = '$user' and instructor='true' and rating='CFIG'));
  $get_info->execute();
  while (my $ans = $get_info->fetchrow_hashref) {
    $answer = $ans->{'handle'};
    }
  $answer;
  }




sub abort {
	# Shows HTML to the screen when called
	# shows what happon. 
	# then dies. 
	# much less rude than the 500 Internal Server Error screen. 
  print h1(qq(Abort)); 
  print h2(qq(The program aborted)); 
  print join "<br>\n", @_; 
  die (join "<br>\n", @_); 
  } 

sub show_question_selection {
	# Different from the test bank creation page, this allows the 
	# instructor to create a written test, based on the 
	# sections he wants to include. 
	# 
  print p(qq(<b>Note:</b> The program not create a test with more than 50 questions. <br><a href="/INSTRUCTORS/TEST/Instructions.pdf">How to use this program</a>));
  print start_form(); 
  my %code_name = code_names(); 
  my %code_count = show_code_counts(); 
  my @code_name_sum;
  my ($code_name_sum, $initialize); 
  for my $code (keys %code_name) {
    next if $code eq ''; 
    next if $code eq 'Select'; 
    next if $code_count{$code} == 0;
    push (@code_name_sum, "parseInt(document.getElementById('$code').value) ");
    $initialize .= "var $code=new Number; $code=0;\n    "; 
    }
  $code_name_sum = join (" + ", @code_name_sum); 
  print <<EOM;
  <script language="JavaScript">
    function forceit (the_type, the_value) {
      document.getElementById(the_type).selectedIndex=the_value;
      sum_total(); 
      }
    function sum_total () {
      document.getElementById("sum_total").innerHTML=
 	$code_name_sum
	;
      }
  </script>
EOM
  print "Sample Test Question Selections:<br> "; 
  print_shortcut_button('ASK-21');
  print_shortcut_button('PW5');
  print_shortcut_button('Discus');
  print_shortcut_button('Empty');

  print h2(qq(Select sections for the test: )); 
  print qq(<table border =1 bgcolor="#F8F8F8">); 
  print "</td></tr>\n"; 
  print qq(<tr bgcolor="#E8E8E8"><td><b>Area</b></td><td><b>Available</b></td><td><b>Weight</b></td></tr>\n); 

  for my $code (sort keys (%code_name)) { 
    next if $code eq ''; 
    printf (qq(</td><td>%s (%s)</td><td align="center">%d</td>\n), 
	$code_name{$code}, 
	$code,
	$code_count{$code}
	);
    if ($code_count{$code} == 0) {
      print qq(<td align="center">N/A</td></tr>); 
      } 
    else { 
      printf qq(<td align="right">) . popup_menu (
	-name => $code, 
	-id => $code,
	-values => [ (0..$code_count{$code}) ],
	-default => 0 ,
	-onclick => "sum_total($code)"
	);
      print "</tr>\n"; 
      }
    } 
  printf (qq(<tr bgcolor="#E8E8E8"><td align="right" colspan="1"><b>Optional: This test <i>must</i> include questions...</b><br><font size="-1">Type out question numbers <br>(listed in parenthesis on any written test, or in any test section), <br>separated by spaces and/or commas. Carriage returns are ignored.</font> </td><td colspan="2">%s</td></tr>\n),
	textarea (
		-name => 'must_include',
		-cols => 20,
		-rows => 6
		));
  print qq(<tr bgcolor="#C8C8C8"><td align="right" colspan="2">Total<br><font size="-1">(not including must-have test questions)</td><td align="right"><p id="sum_total">0</p></td></tr>);
  printf qq(<tr><td colspan="3" align="center">%s</td></tr>\n), 
	submit (
		-name => 'action', 
		-value => 'Create Test'
		); 
  print end_form(); 
  } 

sub print_shortcut_button {
	# Javascript to fill in all the fields necessary for your
	# average run-of-the-mill test for each of the aircraft. 
	# Input is a type of test. 
	# Outputs directly to STDOUT, 
	# no return variables. 
	# Prints the necessary javascript quietly. 
  my ($input) = shift; 
  my (%test_types) = (
	'ASK-21' => {'G103' => 0, 'S136' => 0, 'Cirrus' =>0, 'ASK21' => 100, 'GF' => 10, 'AMF' => 5, 'FAR' => 5, 'GNDOPS' => 5, 'SSC' => 5, 'ST' => 5, 'Weather' => 4, 'AIM' => 5, 'GFH' => 10},
	'PW5' => {'PW5' => 100, 'ASK21' => 0, 'G103' => 0, 'Cirrus' =>0, 'GF' => 10, 'AMF' => 5, 'FAR' => 5, 'GNDOPS' => 5, 'SSC' => 5, 'ST' => 5, 'Weather' => 4, 'AIM' => 5, 'GFH' => 10},
	'Cirrus' => {'Cirrus' => 100, 'ASK21' => 0, 'G103' => 0, 'S136' => 0, 'GF' => 10, 'AMF' => 5, 'FAR' => 5, 'GNDOPS' => 5, 'SSC' => 5, 'ST' => 5, 'Weather' => 4, 'AIM' => 5, 'GFH' => 10},
	'Discus' => {'Cirrus' => 0, 'ASK21' => 0, 'G103' => 0, 'S136' => 0, 'GF' => 10, 'AMF' => 5, 'FAR' => 5, 'GNDOPS' => 5, 'SSC' => 5, 'ST' => 5, 'Weather' => 4, 'AIM' => 5, 'GFH' => 10, 'Discus' => 100},
	'Empty' => {},
	); 
  my ($javascript);
  my %code_count = show_code_counts(); 
  my %code_name = code_names(); 
  for my $type (keys (%code_name)) {
    next if $type eq '';
    next if $code_count{$type} == 0;
    if ($test_types{$input}{$type} > $code_count{$type}) {
      $test_types{$input}{$type} = $code_count{$type}; 
      }
    $code_name{$type} = $test_types{$input}{$type};
    $javascript .= "window.forceit(\"$type\", " . (0+$code_name{$type}) . ");";
    }
  print qq(<input type="button" onClick='$javascript' value="$input">);
  }

sub show_code_counts {
	# For a given question code, we have a certain
	# number in the database of that number. 
	# Return an assoc.array that has the name of the code
	# and the number of questions in test_contents that 
	# are linked with that code name. 
  # my (%code_name) = code_names(); 
  my (%answer); 
  my ($sql) = qq(select code, count(*) as count from test_contents group by code); 
  my $get_info = $dbh->prepare($sql); 
  $get_info->execute();
  while ( my $row = $get_info->fetchrow_hashref ) {
    $answer{$row->{'code'}}= $row->{'count'}; 
    }
  %answer; 
  } 

sub questions_per_section {
	# Input: scalar with question field
	# output: Array of numbers associated 
	# with each question in that code field
	# example:  input('AIM') 
	# output=qw(10 11 12 13 18 33 19 301); 
  my $input  = shift; 
  my @output; 
  my %code_name=code_names(); 
  if ($code_name{$input}) { 
  	# We've validated that whatever they've inputted is actually
	# a field name; which gets us out of sql injection possibilities. 
    my $sql = qq(select qnum from test_contents where code='$input'); 
    my $get_info = $dbh->prepare($sql); 
    $get_info->execute(); 
    while ( my $row = $get_info->fetchrow_hashref ) {
      push (@output, $row->{'qnum'}); 
      }
    }
  @output
  } 

sub show_question_bank {
        # Fetch an array of the questions in order (based on sequence number)
	# put it into a table. 
	# print out the question, 
	#  If we have any input, put it into @fields, those are the codes
	#  we will do a search on. 
  my @codes = @_; 
  my %code_name = code_names(); 
  my %questions;
  my $row;
  my $append; 
  if (@codes) { 
    $append = qq{where (code ='$codes[0]'}; 
    for my $codeseq (1..$#codes) { 
      $append .= "or code = '" .  $codes[$codeseq] . "' ";  
      }
    $append .= ')'; 
    } 

  my ($sql) = qq(select * from test_contents $append);
  my $get_info = $dbh->prepare($sql); 
  $get_info->execute();
  my (@fields) = qw(code question a b c d answer explanation lastupdated updatedby); 
  while ( my $row = $get_info->fetchrow_hashref ) {
    for my $field (@fields) { 
      $questions{$row->{'qnum'}}{$field}= $row->{$field}; 
      } 
    }
  
  print qq(<table border="1" bgcolor= "#E8E8E8">\n); 
  #print qq(<tr bgcolor="black"><td><font color="white">#</font></td>
	#<td><font color="white">Question</font></td>
	#<td><font color="white">Correct</font></td>
	#<td><font color="white">Explanation/Source</font></td>
	#</tr>); 
  for my $qnum (sort bynum keys(%questions)) { 
    printf (qq(<tr><td rowspan="2" align="center">%s%s%s</td><td colspan="2">[%s (%s)]<br>%s<br>
	<ol type="A">
		<li>%s</li>
		<li>%s</li>
		<li>%s</li>
		<li>%s</li></td></tr>
	<tr><td bgcolor="#C8C8C8" align="right">%s</td>
	<td bgcolor="#C8C8C8">%s<br><br><font size="-2"><i>Last updated by %s on %s</i></font></td></tr>
	),
	hidden (-name => 'qnum', -value => $qnum), 
	h3($qnum), 
	submit (-name => 'action', -value => "Edit"), 
	$code_name{$questions{$qnum}{'code'}}, 
	$questions{$qnum}{'code'}, 
	$questions{$qnum}{'question'}, 
	$questions{$qnum}{'a'}, 
	$questions{$qnum}{'b'}, 
	$questions{$qnum}{'c'}, 
	$questions{$qnum}{'d'}, 
	$questions{$qnum}{'answer'}, 
	$questions{$qnum}{'explanation'},
	$questions{$qnum}{'updatedby'},
	$questions{$qnum}{'lastupdated'}
	); 
    } 
  print "</table>"; 
  } 
sub is_question_legit {
	# The instructor has the opportunity to enter in a list of 
	# required questions.  We need to make sure that those questions
	# actually exist in the database. 
	# Be careful to saniteize the input correctly, to prevent 
	# "Little Bobby Tables" syndrome. 
  my ($qnum) = shift; 
	# You're not a number? Eff that.  I'm outta here. 
  return(0) if $qnum !~ /^\d+$/; 
	# OK, still it's possible that this question isn't legit. 
	# Let's do a select on the database to make sure it's in there. 
  my ($answer)=0;
  my $get_info = $dbh->prepare(
        sprintf (qq(select qnum from test_contents where qnum=%d), $qnum));
  $get_info->execute();
  while ( my $row = $get_info->fetchrow_hashref ) {
    $answer++ if $row->{'qnum'} == $qnum; 
    }
  $answer;
  }
sub print_answer { 
	# Just print out the the HTML of the answer,
	# No form stuff. 
	# $qnum as input
  my ($qnum) = shift; 
  my ($question_count) = shift; 
  my ($output); 
  my %code_name = code_names(); 
  my %questions = fetch_question($qnum);
  $questions{$qnum}{'answer'} =~ s/&ensp;|&emsp;|&thinsp;//g; 
  $questions{$qnum}{'explanation'} =~ s/&ensp;|&emsp;|&thinsp;//g; 
  $output = sprintf (qq(<tr><td rowspan="2" align="center" valign="top"><font size=+1>%s<br><font size="-1">(%s)</font></td>
	<td><h3>%s</h3><td><h4>%s</h4></td></tr>
	<tr><td colspan="3">%s</td></tr>
	),
	$question_count,
	$qnum,
	$questions{$qnum}{'answer'}, 
	$questions{$qnum}{lc($questions{$qnum}{'answer'})}, 
	$questions{$qnum}{'explanation'}, 
	); 
  $output; 
  } 


sub print_question { 
	# Just print out the the HTML of the question,
	# No form stuff. 
	# $qnum as input
  my ($qnum) = shift; 
  my ($question_count) = shift; 
  my ($output); 
  my %code_name = code_names(); 
  my %questions = fetch_question($qnum);
  $output .= qq(<font size="-2"><table border="0" style="width : 100%; page-break-inside: avoid;">);
  $output .= sprintf (qq(<tr><td style="background-color : #F8F8F8; width: 50px; page-break-inside: avoid;" align="center" valign="top"><font size=+1>%s<br><font size="-1">(%s)</font></td><td style="page-break-inside: avoid" colspan="2">%s<br>
	<ol type="A" style="page-break-inside: avoid">
		<li>%s</li>
		<li>%s</li>
		<li>%s</li>
		<li>%s</li></td></tr>
	),
	$question_count,
	$qnum,
	$questions{$qnum}{'question'}, 
	$questions{$qnum}{'a'}, 
	$questions{$qnum}{'b'}, 
	$questions{$qnum}{'c'}, 
	$questions{$qnum}{'d'} 
	); 
  $output .= "</table></font>\n"; 
  $output; 
  } 

sub bynum {
  $a <=> $b; 
  } 

sub code_names { 
	# returns an associated array 
	# with the names of all the code fields. 
	# as listed in the database. 
  my (%answer); 
  my $get_info = $dbh->prepare(
        qq(select * from qcodes));
  $get_info->execute();
  while ( my $row = $get_info->fetchrow_hashref ) {
    $answer{$row->{'qcode'}}= $row->{'description'}; 
    }
  $answer{''} = 'Select'; 
  %answer;
  } 

sub fetch_question { 
	# So you feed me a question number, 
	# I will go to the database, and get the db info for that question
	# Then I will return with %answer; 
  my ($question_number) = shift; 
  return if $question_number eq 'new'; 
  my (%question); 
  my $get_info = $dbh->prepare(
        qq(select * from test_contents where qnum = '$question_number'));
  $get_info->execute();
  my (@fields) = qw(code question a b c d answer explanation updatedby lastupdated); 
  while ( my $row = $get_info->fetchrow_hashref ) {
    for my $field (@fields) { 
      $question{$row->{'qnum'}}{$field}= $row->{$field}; 
      } 
    }
  %question
  } 

sub show_question { 
  my (@fields) = qw(code question a b c d answer explanation lastupdated updatedby); 
  my %code_name = code_names(); 
  my (@questions) = @_; 
  print qq(<a href="?">Return to Main</a><br>); 
  print qq(<table border="1" bgcolor= "#E8E8E8">\n); 
  for my $question (@questions) { 
    print start_form(); 
    if ($question eq 'new') { 
      param (-name => 'qnum', -value => 'new'); 
      }
    elsif ( param('validation') eq 'true') { 
	# don't do nottin'! 
      } 
    else { 
      my (%question) = fetch_question($question);
      for my $field (@fields) { 
        param(-name => $field, -value => $question{$question}{$field});
        }
	warn "lastupdated on: " . param('lastupdated'); 
      }
    printf (qq(<tr><td>%s</td></tr>

<tr>
  <td>Select the question code type: 
  <td>%s</td>
</tr>

<tr>
  <td>State the multiple choice question. Use rich text as you see fit.</td>
  <td>%s</td>
</tr>
<tr>
  <td>Enter in possible answers. Fill in all four fields.</td>
  <td>
	<ol type="A">
		<li>%s</li>
		<li>%s</li>
		<li>%s</li>
		<li>%s</li>
  </td>
</tr>
<tr bgcolor="#C8C8C8">
  <td>Select the correct answer from the pull-down</td>
  <td>%s</td>
</tr>
<tr bgcolor="#C8C8C8">
  <td>Explain why that answer is correct. Also please explain why the others are incorrect. Use the rich text to include hyperlinks or tables. </td>
  <td>%s</td>
</tr>
<tr>
  <td>Click Update button when ready to commit these changes to the database. </td>
  <td>%s</td>
</tr>
	),
	hidden (-name => 'qnum', -value => $question), 

	popup_menu (
		-name => 'code', 
		-values => [sort (keys(%code_name))],
		-labels => \%code_name, 
		-default => 'Select'
		), 	

	textarea (
		-name => 'question', 
        	-rows => "10",
        	-cols => "80",
        	-scroll => "auto",
		-value => param('question')
		),

	textfield (
		-name => 'a', 
		-size => '60', 
		),
	
	textfield (
		-name => 'b', 
		-size => '60', 
		),
	
	textfield (
		-name => 'c', 
		-size => '60', 
		),
	
	textfield (
		-name => 'd', 
		-size => '60', 
		),
	
	popup_menu (
		-name => 'answer', 
		-values => ['Select', 'A', 'B', 'C', 'D']
		), 	
	textarea (
		-name => 'explanation', 
        	-rows => "10",
        	-cols => "80",
        	-scroll => "auto",
		-value => param('explanation')
		),
	submit (-name => 'action', -value => "Update"), 
	); 
    print hidden('section'); 
    print "</table>"; 
    if (param('lastupdated')) {
      printf (qq(This question was last updated by %s on %s), 
 	param('updatedby'),
 	param('lastupdated')
	); 
      }
    print end_form(); 
    } 
  } 

sub footer {
	# Simple close up your html and 
	# quit. 
  print include ('footer.scrap');
  print end_html();
  exit;
  } 

sub today {
	# What is today?
  my @today = localtime; 
  sprintf ("%4.4d-%2.2d-%2.2d", $today[5]+1900, $today[4]+1, $today[3]);
  }

sub connectify {
	# Just connect to the database. 
  my $driver = "DBI::Pg";
  my $database = 'skyline';
  $dbh = DBI->connect("DBI:Pg:dbname=skyline")
        || abort ("Can't connect to database $!\n");
  }

sub include {
	# Pull file from the INCLUDES directory
	# output of subroutine is that file.
  my $file = shift;
  my $title = shift;
  my $answer;
  open (INCLUDE, "/var/www/members/INCLUDES/$file"); 
  while (my $line = <INCLUDE>) {
    $answer .= $line;
    }
  close (INCLUDE);
  $answer;
  }

sub fetch_members {
        # Fetch an assoc.array of members.
  my %answer;
  my $status = shift;
  my $row;
  my ($append);
  if ($status eq 'active') {
    $append=qq(where memberstatus != 'I' and memberstatus !='N' );
    }
  my $get_info = $dbh->prepare(
        qq(select handle, lastname, firstname, middleinitial, memberstatus, namesuffix from members $append));
  $get_info->execute();

  while ( my $row = $get_info->fetchrow_hashref ) {
    if ($row->{'namesuffix'} =~ /\w/) {
    $answer{$row->{'handle'}}= sprintf ("%s %s, %s %s",
        $row->{'lastname'},
        $row->{'namesuffix'},
        $row->{'firstname'},
        $row->{'middleinitial'},
        );
      }
    else {
    $answer{$row->{'handle'}}= sprintf ("%s, %s %s",
        $row->{'lastname'},
        $row->{'firstname'},
        $row->{'middleinitial'},
        );
      }
    }
  %answer;
  }


__END__




skyline=> \d test_contents
                                     Table "public.test_contents"
   Column    |         Type         |                            Modifiers
-------------+----------------------+-----------------------------------------------------------------
 qnum        | integer              | not null default nextval('public.test_contents_qnum_seq'::text)
 code        | character varying(8) |
 question    | character varying    |
 a          | character varying    |
 b          | character varying    |
 c          | character varying    |
 d          | character varying    |
 answer      | character varying(2) |
 explanation | character varying    |
Indexes:
    "test_contents_pkey" primary key, btree (qnum)


skyline=> select * from qcodes;
 qcode  |              description
--------+---------------------------------------
 G103   | Grob 103 specific questions
 ASK21  | ASK-21 specific questions
 S136   | Schweizer SGS 1-36 specific questions
 Cirrus | Cirrus specific questions
 AMF    | Aeromedical Factors
 SSC    | Skyline Soaring Club questions
 FAR    | Federal Regulations
 AIM    | Aeronautical Information Manual
 ST     | Soaring Technique
 GF     | Glider Flying Technique
 WX     | Weather
 GFH    | Glider Flying General Knowledge
(12 rows)


