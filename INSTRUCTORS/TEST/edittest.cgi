#!/usr/bin/perl

	# Little program to allow the Instructors
	# to edit the Training Syllabus Lesson Plans
	# that are located on the club website
	# under http://skylinesoaring.org/TRAINING/Syllabus/


	# Todo: 
	
    	# Non-goals
    	# [X] True/false questions
    	# [X] essay answers by the student
	# 
    	# Immediate To-do list:   This can be done tomorrow, if work isn't busy:
    	# [X] make better messages for when success or failure for updating/creating questions
    	# [X] make default page give you an option to view the questions based on the category
	# 
	# 
    	# Later to-do list:  This can be done this week, so long as I don't get distracted by video games.  
	# 
    	# [X] Check for the input of all required fields on submission.  Right now, it will bomb out if 
	#     you submit a new or edited question with "Select" listed as the correct answer.
	# [X] Get the proper username and timestamp for last updated appended to the bottom of the answer block. 
    	# [X] email people (me, really; all instructors later) when changes are made, so I can see when 
	#     instructors are changing stuff.  "Who the hell put in a question about helicopters?!"
    	# [X] get the quality of the questions good enough to generate a test with specific subjects for 
	#     a particular club member.
    	# [X] get other instructors to beta test.  Jim Kellett, John Noss, Joe Parrish like to beta test.
	#     They will be harsh critics of the questions and especially the answers.  You'd better have your questions
	#     perfect. 
	# 
    	# Student Test Experience:
    	# [ ] Start.
    	# [ ] Have the student pick up a test generated by the instructor
    	# [ ] One big page that doesn't let the student use the back button to fix the test problems
    	# [ ] Include time limit javascript to pressure the student into making stupid decisions based on a time limit
    	# [ ] Enter results of written tests into their flight training record, including and especially including 
	#     links to the incorrect answers.
    	# [ ] Come up with a 1WH to keep the student from figuring out how to snoop the whole test bank by clever 
	#     use of URLs and hackery. 
	# 
	# Paper test experience:
	# [ ] Start
	# [ ] Just take a bank of questions and output a PDF for the instructor to download. 
	# 

$|++;
use strict;
#my ($the_instructor) = 'pbarber'; 
my ($the_instructor) = $ENV{'REMOTE_USER'}; 

use CGI qw(:standard);
use DBI;
my ($dbh);
connectify();
my $javascript=javascript();

if (param('action') eq 'Update') { 
  print	header();
  print "<!DOCTYPE HTML>\n";
  validate_input(); 
  print join ("\n", 
	"<html><head><title>Updating Question Database...</title>\n",
	$javascript,
	"</head>\n",
	include('left-menu.scrap'),
	h1("Updating Question Database..."),
	);
  if (param('no_email') eq 'This is a minor change')  {
    print h2(qq(Skipping email));
    }
  else {
    email_differences();
    }
  insert_question(param('qnum'));
  footer(); 
  } 

elsif (param('action') eq 'Add a Question') {
  print	header();
  print "<!DOCTYPE HTML>\n";
  print join ("\n", 
	"<html><head><title>Add a new Question</title>\n",
	$javascript,
	"</head>\n",
	include('left-menu.scrap'),
	h1("Add a new Question "),
	);
  show_question('new');
  footer(); 
  }

elsif ((param('action') eq 'Edit' || param('action') eq 'Edit Test Questions') && (param('qnum') =~ /^\d+$/)) {
  print	header();
  print "<!DOCTYPE HTML>\n";
  print join ("\n", 
	"<html><head><title>Edit Question " . param('qnum') . "</title>\n",
	$javascript,
	"</head>\n",
	include('left-menu.scrap'),
	h1("Edit Question " . param('qnum')),
	);
  show_question(param('qnum'));
  footer(); 
  }

elsif (param ('sections') && param ('action') eq 'Show') {
  print join ("\n",
    header(),
    "<!DOCTYPE HTML>",
    start_html(-title => "Select From Question Bank"),
    include('left-menu.scrap'),
    start_form(), 
    h1("Edit our written test"), 
    qq(<a href="?">Return to Start</a><br>), 
    qq(<a href="/INSTRUCTORS/TEST/">Return to Tests Main Page</a><br>), 
    h2(qq(Create a new question)), 	
    p(submit (-name => 'action', -value => "Add a Question")),
    hr()
    );
  show_question_bank(param('sections')); 
  show_question_selection(); 
  print join ("\n", 
    start_form(),
    edit_one_question_selection(),
    end_form()
    );
  }

else { 
  print join ("\n",
    header(),
    "<!DOCTYPE HTML>",
    start_html(-title => "Select From Question Bank"),
    include('left-menu.scrap'),
    h1("Edit our written test"), 
    qq(<a href="?">Return to Main</a><br>), 
    qq(<a href="/INSTRUCTORS/TEST/">Return to Tests Main Page</a><br>), 
    h2(qq(Create a new question)), 
    start_form(), 
    p(submit (-name => 'action', -value => "Add a Question")),
    end_form()
    );
  show_question_selection(); 
  print join ("\n", 
    start_form( -method => 'GET'),
    edit_one_question_selection(),
    end_form()
    );
  } 

footer(); 

	# Subroutines lie here and yonder!

sub email_differences { 
	# First, get input, which is nothing. 
	# second, scrape through param
	# third, fetch previous stuff in database 
	# fourth, compare and contrast differences
	# fifth, construct these differences in an email 
	# sixth, send out into the email stream for 
	#        the instructors to read at their leisure. 

	# If this is a new question, don't bother making a comparison. 
	#   just crow about the new question and the available options. 

	# Make sure to include a link for the instructors to let them 
	# log right back in and update it if they feel it's necessary. 

  my ($email_to) ='instructors@skylinesoaring.org'; 
  #my ($email_to) ='pb@pietbarber.com';

  my ($random_num);
  my (@allow_chars) = (0..9);
  for (1..24) {
    $random_num .= $allow_chars[int(rand($#allow_chars))];
    }
  my $question; 
  if (param('qnum') eq 'new') { 
    $question = "A new question has been added to the test bank.<br>". 
	qq(<table border="1" bgcolor="#e8e8e8">) . 
	print_question('new', 'new') . 
	qq(</table>); 
    }
  else { 
    my $old_content=print_question(param('qnum'),'old'); 
    my $new_content=print_question('new', 'new');  
    my ($qnum) = param('qnum'); 
    $question =<<EOM; 
A question has been updated in the test bank: 
<h2>Old Content (#$qnum) </h2>
<table border="1" bgcolor="#e8e8e8">
$old_content
</table>
<h2>New Content</h2>
<table border="1" bgcolor="#e8e8e8">
$new_content
</table>

EOM
    } 
  $question =~ s/%/%%/g;
  open (SENDMAIL, "|-") || exec ('/usr/sbin/sendmail', '-t', '-oi'); 
  printf SENDMAIL <<EOM, end_html();
From: "Skyline Instructors" <webmaster\@skylinesoaring.org>
MIME-Version: 1.0
X-Accept-Language: en-us, en
To: <$email_to>
Subject: Test Content Update
Content-Type: multipart/alternative;
 boundary="------------$random_num"
This is a multi-part message in MIME format.
--------------$random_num
Content-Type: text/html; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit

<!DOCTYPE HTML>
<html>
<head>
  <meta content="text/html;charset=ISO-8859-1" http-equiv="Content-Type">
  <title>Test Content Update</title>
</head>
<body bgcolor="#ffffff" text="#000000">
$question

Update Test Questions by going to: <br>
<a href = "http://members.skylinesoaring.org/INSTRUCTORS/TEST/">http://members.skylinesoaring.org/INSTRUCTORS/TEST/</a>
%s
--------------$random_num--

EOM

  close (SENDMAIL);
  print "Email sent. "; 
  } 


sub validate_input {
	# 
	# No input. 
	# Take the param() and figure out if we have everything that we need
	# before we try to write this into the database. 
  param('validation', 'true'); 
  my (@fields)=( 
	'question', 
	'a', 
	'b', 
	'c', 
	'd', 
	'explanation');
  my (@error); 
  for my $field (@fields) { 
    if (param($field) eq '' ) { 
      push (@error, "Missing something in the field named: '" . $field . "'") ;
      } 
    }
  if (param('answer') !~ /^[A-D]$/) { 
    push (@error, "You have to select an answer A through D for the answer") ; 
    }
  if (param('code') eq 'Select' || param('code') eq '') {
    push (@error, "You have to select a question category code. "); 
    }
  if (!(is_user_instructor($the_instructor))) { 
    push (@error, "I don't know how you got here, but I don't think you're an instructor, and therefore shouldn't be editing our questions. "); 
    } 

  if (@error) {
    print join ("\n",
        "<html><head><title>Validation Failure...</title>\n",
        $javascript,
        "</head>\n",
        include('left-menu.scrap'),
        h1("Validation Failure"),
        h2("There are errors with your input"),
        );
    print qq(<table border="1" bgcolor="#FFE8E8">); 
    for my $error (@error) { 
      print qq(<tr><td>$error</td></tr>\n); 
      } 
    print "</table>\n"; 
    show_question(param('qnum'));
    footer();
    } 
  } 

sub is_user_instructor {
        # Get information about this user who is logged in
        # see what kind of reports he/she can view.
        # Are you an instructor? If so you can see anything
        # Are you a student? Then you can only see reports about you...
        # ...You can also only see reports that are safe for your virgin
        # eyes to view. (which the instructor determined).

  my $user = shift;
  my $answer;
  my $get_info = $dbh->prepare(qq(select handle from members where handle = '$user' and instructor='true' and rating='CFIG'));
  $get_info->execute();
  while (my $ans = $get_info->fetchrow_hashref) {
    $answer = $ans->{'handle'};
    }
  $answer;
  }


sub insert_question {

  my (@fields)=( 
 	param('code'), 
	param('question'), 
	param('a'), 
	param('b'), 
	param('c'), 
	param('d'), 
	param('answer'), 
	param('explanation'),
	(scalar gmtime(time)), 
	$ENV{'REMOTE_USER'}); 
  if (param('qnum') eq 'new') { 
    print "Adding a brand-new question";
    my ($sql) = qq(insert into test_contents values (default, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?));
    my $get_info = $dbh->prepare($sql); 
    my $rv = $get_info->execute(@fields); 
    if (!$rv) {
      abort("something has gone wrong with the insert. Clues to failure: SQL: $sql; fields: ". 
	join (":",@fields));  
      }

    else {
      print h2(qq(Data Entry Successful)); 
      show_add_question(); 
      show_question_selection(); 
      print join ("\n", 
        start_form(),
        edit_one_question_selection(),
        end_form()
        );
      footer();  
      }
    } 
  elsif (param('qnum') =~ /^\d+$/) { 
    my ($qnum) = param('qnum');
    my ($sql) = qq(update test_contents set code=?, question=?, a=?, b=?, c=?, d=?, answer=?, explanation=?, lastupdated=?, updatedby=? where qnum=$qnum);
    my $get_info = $dbh->prepare($sql); 
    my $rv = $get_info->execute(@fields); 
    if (!$rv) {
      abort("something has gone wrong with the insert. Clues to failure: SQL: $sql; fields: ". 
	join (":",@fields));  
      }
    else {
      print h2(qq(Data Entry Successful)); 
      show_add_question(); 
      show_question_selection(); 
      print join ("\n", 
        start_form(),
        edit_one_question_selection(),
        end_form()
        );
      footer();  
      }
    }
  } 

sub show_add_question { 
	# Shows the page for adding a new question. 
	# 
  print join ("\n", (
	start_form(), 
	h1("Edit our written test"), 
	qq(<a href="?">Return to Main</a><br>), 
        qq(<a href="/INSTRUCTORS/TEST/">Return to Tests Main Page</a><br>), 
	h2(qq(Create a new question)), 	
	p(submit (-name => 'action', -value => "Add a Question")),
        end_form(), 
	hr()
	)); 
  } 

sub abort {
	# Shows HTML to the screen when called
	# shows what happon. 
	# then dies. 
	# much less rude than the 500 Internal Server Error screen. 
  print h1(qq(Abort)); 
  print h2(qq(The program aborted)); 
  print join "<br>\n", @_; 
  die (join "<br>\n", @_); 
  } 

sub show_question_selection {
	# 
  print h2(qq(Select sections to edit: )); 
  print qq(<table border =1 bgcolor="#E8E8E8">); 
  print start_form(); 
  my %code_name = code_names(); 
  my %code_count = show_code_counts(); 
  for my $code (sort keys (%code_name)) { 
    next if $code eq ''; 
    printf "<tr><td>" . checkbox (
	-name => 'sections', 
	-label => sprintf ("%s [%d]", $code_name{$code}, $code_count{$code}), 
	-value => $code
	) . "</td></tr>\n";
    } 
  printf qq(<tr><td>%s</td></tr>\n), 
	submit (
		-name => 'action', 
		-value => 'Show'
		); 
  print "</table>"; 
  print end_form(); 
  } 

sub show_code_counts {
	# For a given question code, we have a certain
	# number in the database of that number. 
	# Return an assoc.array that has the name of the code
	# and the number of questions in test_contents that 
	# are linked with that code name. 
  # my (%code_name) = code_names(); 
  my (%answer); 
  my ($sql) = qq(select code, count(*) as count from test_contents group by code); 
  my $get_info = $dbh->prepare($sql); 
  $get_info->execute();
  while ( my $row = $get_info->fetchrow_hashref ) {
    $answer{$row->{'code'}}= $row->{'count'}; 
    }
  %answer; 
  } 

sub edit_one_question_selection {
  my ($answer, @questions); 
  my ($sql) = qq(select qnum from test_contents); 
  my ($get_info) = $dbh->prepare($sql); 
  $get_info->execute(); 
  while ( my $row = $get_info->fetchrow_hashref ) {
    push (@questions, $row->{'qnum'}); 
    }
  $answer .= h2('Edit Just One Question');
  $answer .= qq(Edit question number ); 
  $answer .= popup_menu (
	-name => 'qnum',
	-values => [sort bynum @questions]
	);
  $answer .= submit (-name => 'action', -value => "Edit");
  $answer;
  } 

sub show_question_bank {
        # Fetch an array of the questions in order (based on sequence number)
	# put it into a table. 
	# print out a checkbox, with the number of the question to edit, 
	# print out the question, the answers, highlight the correct answer
	#  If we have any input, put it into @fields, those are teh codes
	#  we will do a search on. 
  my @codes = @_; 
  my %code_name = code_names(); 
  my %questions;
  my $row;
  my $append; 
  if (@codes) { 
    $append = qq{where (code ='$codes[0]'}; 
    for my $codeseq (1..$#codes) { 
      $append .= "or code = '" .  $codes[$codeseq] . "' ";  
      }
    $append .= ')'; 
    } 

  my ($sql) = qq(select * from test_contents $append);
  my $get_info = $dbh->prepare($sql); 
  $get_info->execute();
  my (@fields) = qw(code question a b c d answer explanation lastupdated updatedby); 
  while ( my $row = $get_info->fetchrow_hashref ) {
    for my $field (@fields) { 
      $questions{$row->{'qnum'}}{$field}= $row->{$field}; 
      } 
    }
  
  print qq(<table border="1" bgcolor= "#E8E8E8">\n); 
  #print qq(<tr bgcolor="black"><td><font color="white">#</font></td>
	#<td><font color="white">Question</font></td>
	#<td><font color="white">Correct</font></td>
	#<td><font color="white">Explanation/Source</font></td>
	#</tr>); 
  for my $qnum (sort bynum keys(%questions)) { 
    print start_form(); 
    printf (qq(<tr><td rowspan="2" align="center">%s%s%s</td><td colspan="2">[%s (%s)]<br>%s<br>
	<ol type="A">
		<li>%s</li>
		<li>%s</li>
		<li>%s</li>
		<li>%s</li></td></tr>
	<tr><td bgcolor="#C8C8C8" align="right">%s</td>
	<td bgcolor="#C8C8C8">%s<br><br><font size="-2"><i>Last updated by %s on %s</i></font></td></tr>
	),
	hidden (-name => 'qnum', -value => $qnum), 
	h3($qnum), 
	submit (-name => 'action', -value => "Edit"), 
	$code_name{$questions{$qnum}{'code'}}, 
	$questions{$qnum}{'code'}, 
	$questions{$qnum}{'question'}, 
	$questions{$qnum}{'a'}, 
	$questions{$qnum}{'b'}, 
	$questions{$qnum}{'c'}, 
	$questions{$qnum}{'d'}, 
	$questions{$qnum}{'answer'}, 
	$questions{$qnum}{'explanation'},
	$questions{$qnum}{'updatedby'},
	$questions{$qnum}{'lastupdated'}
	); 
    print end_form(); 
    } 
  print "</table>"; 
  } 

sub print_question { 
	# Just print out the the HTML of the question,
	# No form stuff. 
	# $qnum as input
  my ($qnum) = shift; 
  my ($status) = shift; 
  my ($output); 
  my (%questions); 
  my %code_name = code_names(); 
  if ($status eq 'old') { 
    %questions = fetch_question($qnum); 
    } 
  elsif ($status eq 'new') { 
    $qnum='new'; 
    my (@fields) = qw(code question a b c d answer explanation lastupdated updatedby); 
    for my $field (@fields) { 
      $questions{$qnum}{$field} = param($field); 
      } 
    $questions{$qnum}{'lastupdated'} = scalar localtime(time); 
    $questions{$qnum}{'updatedby'} = $the_instructor; 
    } 
  
  $output = sprintf (qq(<tr><td rowspan="2" align="center">%s</td><td colspan="2">[%s (%s)]<br>%s<br>
	<ol type="A">
		<li>%s</li>
		<li>%s</li>
		<li>%s</li>
		<li>%s</li></td></tr>
	<tr><td bgcolor="#C8C8C8" align="right">%s</td>
	<td bgcolor="#C8C8C8">%s<br><br><font size="-2"><i>Last updated by %s on %s</i></font></td></tr>
	),
	$status,
	$code_name{$questions{$qnum}{'code'}}, 
	$questions{$qnum}{'code'}, 
	$questions{$qnum}{'question'}, 
	$questions{$qnum}{'a'}, 
	$questions{$qnum}{'b'}, 
	$questions{$qnum}{'c'}, 
	$questions{$qnum}{'d'}, 
	$questions{$qnum}{'answer'}, 
	$questions{$qnum}{'explanation'},
	$questions{$qnum}{'updatedby'},
	$questions{$qnum}{'lastupdated'}
	); 
  $output; 
  } 


sub bynum {
  $a <=> $b; 
  } 

sub code_names { 
	# returns an associated array 
	# with the names of all the code fields. 
	# as listed in the database. 
  my (%answer); 
  my $get_info = $dbh->prepare(
        qq(select * from qcodes));
  $get_info->execute();
  while ( my $row = $get_info->fetchrow_hashref ) {
    $answer{$row->{'qcode'}}= $row->{'description'}; 
    }
  $answer{''} = 'Select'; 
  %answer;
  } 

sub fetch_question { 
	# So you feed me a question number, 
	# I will go to the database, and get the db info for that question
	# Then I will return with %answer; 
  my ($question_number) = shift; 
  return if $question_number eq 'new'; 
  my (%question); 
  my $get_info = $dbh->prepare(
        qq(select * from test_contents where qnum = '$question_number'));
  $get_info->execute();
  my (@fields) = qw(code question a b c d answer explanation updatedby lastupdated); 
  while ( my $row = $get_info->fetchrow_hashref ) {
    for my $field (@fields) { 
      $question{$row->{'qnum'}}{$field}= $row->{$field}; 
      } 
    }
  %question
  } 

sub show_question { 
  my (@fields) = qw(code question a b c d answer explanation lastupdated updatedby); 
  my %code_name = code_names(); 
  my (@questions) = @_; 
  print qq(<a href="?">Return to Main</a><br>),
    qq(<a href="/INSTRUCTORS/TEST/">Return to Tests Main Page</a><br>); 
  print qq(<table border="1" bgcolor= "#E8E8E8">\n); 
  for my $question (@questions) { 
    print start_form(); 
    if ($question eq 'new') { 
      param (-name => 'qnum', -value => 'new'); 
      }
    elsif ( param('validation') eq 'true') { 
	# don't do nottin'! 
      } 
    else { 
      my (%question) = fetch_question($question);
      for my $field (@fields) { 
        param(-name => $field, -value => $question{$question}{$field});
        }
	warn "lastupdated on: " . param('lastupdated'); 
      }
    printf (qq(

<tr>
  <td width=30%>Select the question code type: %s
  <td>%s</td>
</tr>

<tr>
  <td>State the multiple choice question. Use rich text as you see fit.</td>
  <td>%s</td>
</tr>
<tr>
  <td>Enter possible answers. Fill in all four fields.</td>
  <td>
	<ol type="A">
		<li>%s</li>
		<li>%s</li>
		<li>%s</li>
		<li>%s</li>
  </td>
</tr>
<tr bgcolor="#C8C8C8">
  <td>Select the correct answer from the pull-down</td>
  <td>%s</td>
</tr>
<tr bgcolor="#C8C8C8">
  <td>Explain why that answer is correct. Also please explain why the others are incorrect. Use the rich text to include hyperlinks or tables. </td>
  <td>%s</td>
</tr>
<tr>
  <td>Click Update button when ready to commit these changes to the database. </td>
  <td>%s<br>%s</td>
</tr>
	),
	hidden (-name => 'qnum', -value => $question), 

	popup_menu (
		-name => 'code', 
		-values => [sort (keys(%code_name))],
		-labels => \%code_name, 
		-default => 'Select'
		), 	

	textarea (
		-name => 'question', 
        	-rows => "10",
        	-cols => "80",
        	-scroll => "auto",
		-value => param('question')
		),

	textfield (
		-name => 'a', 
		-size => '100', 
		),
	
	textfield (
		-name => 'b', 
		-size => '100', 
		),
	
	textfield (
		-name => 'c', 
		-size => '100', 
		),
	
	textfield (
		-name => 'd', 
		-size => '100', 
		),
	
	popup_menu (
		-name => 'answer', 
		-values => ['Select', 'A', 'B', 'C', 'D']
		), 	
	textarea (
		-name => 'explanation', 
        	-rows => "10",
        	-cols => "80",
        	-scroll => "auto",
		-value => param('explanation')
		),
	checkbox (-name => 'no_email', 
		-value => 'This is a minor change',
		-label => qq(This is a minor change (Don't send email))
		),
	submit (-name => 'action', -value => "Update"), 
	); 
    print hidden('section'); 
    print "</table>"; 
    if (param('lastupdated')) {
      printf (qq(This question was last updated by %s on %s), 
 	param('updatedby'),
 	param('lastupdated')
	); 
      }
    print end_form(); 
    } 
  } 

sub footer {
	# Simple close up your html and 
	# quit. 
  print include ('footer.scrap');
  print end_html();
  exit;
  } 

sub today {
	# What is today?
  my @today = localtime; 
  sprintf ("%4.4d-%2.2d-%2.2d", $today[5]+1900, $today[4]+1, $today[3]);
  }

sub connectify {
	# Just connect to the database. 
  my $driver = "DBI::Pg";
  my $database = 'skyline';
  $dbh = DBI->connect("DBI:Pg:dbname=skyline")
        || die ("Can't connect to database $!\n");
  }

sub include {
	# Pull file from the INCLUDES directory
	# output of subroutine is that file.
  my $file = shift;
  my $title = shift;
  my $answer;
  open (INCLUDE, "/var/www/members/INCLUDES/$file"); 
  while (my $line = <INCLUDE>) {
    $answer .= $line;
    }
  close (INCLUDE);
  $answer;
  }

sub javascript {
  my $answer=<<EOM;
<!-- TinyMCE -->
<script src="/INCLUDES/tinymce/js/tinymce/tinymce.min.js"></script>
<script>
	tinymce.init({
		selector: "textarea",
			plugins: [
			  'advlist', 'autolink', 'link', 'image', 'lists', 'charmap', 'preview', 'anchor', 'pagebreak',
			  'searchreplace', 'wordcount', 'visualblocks', 'visualchars', 'code', 'fullscreen', 'insertdatetime',
			  'media', 'table', 'emoticons', 'help'
			],
		toolbar: 'undo redo | styles | bold italic | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | link image | forecolor backcolor emoticons',
		autosave_ask_before_unload: false,
		relative_urls : false,
        	convert_urls: false,
		});
</script>
EOM
  $answer;
  }


__END__




skyline=> \d test_contents
                                     Table "public.test_contents"
   Column    |         Type         |                            Modifiers
-------------+----------------------+-----------------------------------------------------------------
 qnum        | integer              | not null default nextval('public.test_contents_qnum_seq'::text)
 code        | character varying(8) |
 question    | character varying    |
 a          | character varying    |
 b          | character varying    |
 c          | character varying    |
 d          | character varying    |
 answer      | character varying(2) |
 explanation | character varying    |
Indexes:
    "test_contents_pkey" primary key, btree (qnum)


skyline=> select * from qcodes;
 qcode  |              description
--------+---------------------------------------
 G103   | Grob 103 specific questions
 ASK21  | ASK-21 specific questions
 S136   | Schweizer SGS 1-36 specific questions
 Cirrus | Cirrus specific questions
 AMF    | Aeromedical Factors
 SSC    | Skyline Soaring Club questions
 FAR    | Federal Regulations
 AIM    | Aeronautical Information Manual
 ST     | Soaring Technique
 GF     | Glider Flying Technique
 WX     | Weather
 GFH    | Glider Flying General Knowledge
(12 rows)


